"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemPersist = void 0;
exports.getStorageDirectory = getStorageDirectory;
const node_os_1 = require("node:os");
const node_path_1 = require("node:path");
const node_crypto_1 = require("node:crypto");
const api_1 = require("@opentelemetry/api");
const fileAccessControl_js_1 = require("./fileAccessControl.js");
const fileSystemHelpers_js_1 = require("./fileSystemHelpers.js");
const promises_1 = require("node:fs/promises");
const types_js_1 = require("../../../export/statsbeat/types.js");
/**
 * File system persist class.
 * @internal
 */
class FileSystemPersist {
    _options;
    _customerSDKStatsMetrics;
    static TEMPDIR_PREFIX = "opentelemetry-nodejs-";
    static FILENAME_SUFFIX = ".ai.json";
    fileRetemptionPeriod = 2 * 24 * 60 * 60 * 1000; // 2 days
    cleanupTimeOut = 60 * 60 * 1000; // 1 hour
    maxBytesOnDisk = 50_000_000; // ~50MB
    _enabled;
    _tempDirectory = "";
    _fileCleanupTimer = null;
    _instrumentationKey;
    constructor(instrumentationKey, _options, _customerSDKStatsMetrics) {
        this._options = _options;
        this._customerSDKStatsMetrics = _customerSDKStatsMetrics;
        this._instrumentationKey = instrumentationKey;
        if (this._options?.disableOfflineStorage) {
            this._enabled = false;
            return;
        }
        this._enabled = true;
        fileAccessControl_js_1.FileAccessControl.checkFileProtection();
        if (!fileAccessControl_js_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
            this._enabled = false;
            api_1.diag.error("Sufficient file protection capabilities were not detected. Files will not be persisted");
        }
        if (!this._instrumentationKey) {
            this._enabled = false;
            api_1.diag.error(`No instrumentation key was provided to FileSystemPersister. Files will not be persisted`);
        }
        if (this._enabled) {
            this._tempDirectory = getStorageDirectory(this._instrumentationKey, this._options?.storageDirectory);
            // Starts file cleanup task
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setTimeout(() => {
                    this._fileCleanupTask();
                }, this.cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    push(value) {
        if (this._enabled) {
            api_1.diag.debug("Pushing value to persistent storage", value.toString());
            return this._storeToDisk(JSON.stringify(value), value);
        }
        // Only return a false promise if the SDK isn't set to disable offline storage
        if (!this._options?.disableOfflineStorage) {
            return new Promise((resolve) => {
                resolve(false);
            });
        }
        return new Promise((resolve) => {
            resolve(true);
        });
    }
    async shift() {
        if (this._enabled) {
            api_1.diag.debug("Searching for filesystem persisted files");
            try {
                const buffer = await this._getFirstFileOnDisk();
                if (buffer) {
                    return JSON.parse(buffer.toString("utf8"));
                }
            }
            catch (e) {
                api_1.diag.debug("Failed to read persisted file", e);
            }
            return null;
        }
        return new Promise((resolve) => {
            resolve(null);
        });
    }
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    async _getFirstFileOnDisk() {
        try {
            const stats = await (0, promises_1.stat)(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await (0, promises_1.readdir)(this._tempDirectory);
                const files = origFiles.filter((f) => (0, node_path_1.basename)(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return null;
                }
                else {
                    const firstFile = files[0];
                    const filePath = (0, node_path_1.join)(this._tempDirectory, firstFile);
                    const payload = await (0, promises_1.readFile)(filePath);
                    // delete the file first to prevent double sending
                    await (0, promises_1.unlink)(filePath);
                    return payload;
                }
            }
            return null;
        }
        catch (e) {
            if (e.code === "ENOENT") {
                // File does not exist -- return null instead of throwing
                return null;
            }
            else {
                throw e;
            }
        }
    }
    /**
     * Stores telemetry data to disk.
     * @param payload - The telemetry data to store.
     * @param envelopeLength -The length of the telemetry envelope.
     * @returns A promise that resolves to true if the data was stored successfully, false otherwise.
     */
    async _storeToDisk(payload, envelopes) {
        try {
            await (0, fileSystemHelpers_js_1.confirmDirExists)(this._tempDirectory);
        }
        catch (error) {
            // Check if error is due to permission/readonly issues
            if (error?.code === "EACCES" || error?.code === "EPERM") {
                this._customerSDKStatsMetrics?.countDroppedItems(envelopes, types_js_1.DropCode.CLIENT_READONLY);
                api_1.diag.warn(`Permission denied while checking/creating directory: ${this._tempDirectory}`, error?.message);
            }
            else {
                api_1.diag.warn(`Error while checking/creating directory: `, error && error.message);
            }
            return false;
        }
        try {
            const size = await (0, fileSystemHelpers_js_1.getShallowDirectorySize)(this._tempDirectory);
            if (size > this.maxBytesOnDisk) {
                // If the directory size exceeds the max limit, we send customer SDK Stats and warn the user
                this._customerSDKStatsMetrics?.countDroppedItems(envelopes, types_js_1.DropCode.CLIENT_PERSISTENCE_CAPACITY);
                api_1.diag.warn(`Not saving data due to max size limit being met. Directory size in bytes is: ${size}`);
                return false;
            }
        }
        catch (error) {
            api_1.diag.warn(`Error while checking size of persistence directory: `, error && error.message);
            return false;
        }
        const fileName = `${new Date().getTime()}${FileSystemPersist.FILENAME_SUFFIX}`;
        const fileFullPath = (0, node_path_1.join)(this._tempDirectory, fileName);
        // Mode 600 is w/r for creator and no read access for others
        api_1.diag.info(`saving data to disk at: ${fileFullPath}`);
        try {
            await (0, promises_1.writeFile)(fileFullPath, payload, { mode: 0o600 });
        }
        catch (writeError) {
            // If the envelopes cannot be written to disk, we send customer SDK Stats and warn the user
            this._customerSDKStatsMetrics?.countDroppedItems(envelopes, types_js_1.DropCode.CLIENT_EXCEPTION, writeError?.message, types_js_1.ExceptionType.STORAGE_EXCEPTION);
            api_1.diag.warn(`Error writing file to persistent file storage`, writeError);
            return false;
        }
        return true;
    }
    async _fileCleanupTask() {
        try {
            const stats = await (0, promises_1.stat)(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await (0, promises_1.readdir)(this._tempDirectory);
                const files = origFiles.filter((f) => (0, node_path_1.basename)(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return false;
                }
                else {
                    files.forEach(async (file) => {
                        // Check expiration
                        const fileCreationDate = new Date(parseInt(file.split(FileSystemPersist.FILENAME_SUFFIX)[0]));
                        const expired = new Date(+new Date() - this.fileRetemptionPeriod) > fileCreationDate;
                        if (expired) {
                            const filePath = (0, node_path_1.join)(this._tempDirectory, file);
                            await (0, promises_1.unlink)(filePath);
                        }
                    });
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            api_1.diag.info(`Failed cleanup of persistent file storage expired files`, error);
            return false;
        }
    }
}
exports.FileSystemPersist = FileSystemPersist;
/**
 * Return the deterministic local storage path for a given instrumentation key.
 *
 * On shared Linux hosts the first user to create `/tmp/Microsoft/AzureMonitor` can
 * block others because the directory inherits that user's `umask`. This is avoided by
 * inserting a hash of the instrumentation key, user name, process name, and
 * application directory, giving each user their own subdirectory, e.g.
 * `/tmp/Microsoft-AzureMonitor-1234...../opentelemetry-nodejs-<ikey>`.
 *
 * @param instrumentationKey - Application Insights instrumentation key.
 * @param storageDirectory - Optional custom storage directory path. If not provided, system temp directory is used.
 * @returns Absolute path to the storage directory.
 * @internal
 */
function getStorageDirectory(instrumentationKey, storageDirectory) {
    let userSegment;
    let processName;
    let applicationDirectory;
    try {
        const user = (0, node_os_1.userInfo)();
        userSegment = user.username;
    }
    catch (error) {
        userSegment = "";
    }
    if (process.title.length > 0) {
        processName = process.title;
    }
    else {
        processName = "";
    }
    const applicationDir = (0, node_path_1.dirname)(process.cwd() || process.argv[1]);
    if (applicationDir) {
        applicationDirectory = applicationDir;
    }
    else {
        applicationDirectory = "";
    }
    const hash_input = `${instrumentationKey}|${userSegment}|${processName}|${applicationDirectory}`;
    let subDirectory;
    try {
        subDirectory = (0, node_crypto_1.createHash)("sha256").update(hash_input).digest("hex");
    }
    catch (error) {
        let hash = 5381;
        for (let i = 0; i < hash_input.length; i++) {
            const char = hash_input.charCodeAt(i);
            hash = (hash << 5) + hash + char;
            hash = hash & hash;
        }
        subDirectory = Math.abs(hash).toString(16);
    }
    let sharedRoot;
    if (storageDirectory) {
        sharedRoot = storageDirectory;
    }
    else {
        sharedRoot = (0, node_os_1.tmpdir)();
    }
    return (0, node_path_1.join)(sharedRoot, "Microsoft-AzureMonitor-" + subDirectory, FileSystemPersist.TEMPDIR_PREFIX + instrumentationKey);
}
//# sourceMappingURL=fileSystemPersist.js.map