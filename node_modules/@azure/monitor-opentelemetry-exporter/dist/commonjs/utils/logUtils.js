"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.logToEnvelope = logToEnvelope;
const index_js_1 = require("../generated/index.js");
const common_js_1 = require("./common.js");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const types_js_1 = require("../types.js");
const types_js_2 = require("../types.js");
const api_1 = require("@opentelemetry/api");
const applicationinsights_js_1 = require("./constants/applicationinsights.js");
/**
 * Log to Azure envelope parsing.
 * @internal
 */
function logToEnvelope(log, ikey) {
    const time = (0, common_js_1.hrTimeToDate)(log.hrTime);
    const sampleRate = 100;
    const instrumentationKey = ikey;
    const tags = createTagsFromLog(log);
    // eslint-disable-next-line prefer-const
    let [properties, measurements] = createPropertiesFromLog(log);
    let name;
    let baseType;
    let baseData;
    const exceptionStacktrace = log.attributes[semantic_conventions_1.ATTR_EXCEPTION_STACKTRACE];
    const exceptionType = log.attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE];
    const isExceptionType = !!(exceptionType && exceptionStacktrace) || false;
    const isMessageType = !log.attributes[applicationinsights_js_1.ApplicationInsightsBaseType] &&
        !log.attributes[applicationinsights_js_1.ApplicationInsightsCustomEventName] &&
        !exceptionType;
    if (isExceptionType) {
        const exceptionMessage = log.attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE];
        name = applicationinsights_js_1.ApplicationInsightsExceptionName;
        baseType = applicationinsights_js_1.ApplicationInsightsExceptionBaseType;
        const exceptionDetails = {
            typeName: String(exceptionType),
            message: String(exceptionMessage),
            hasFullStack: exceptionStacktrace ? true : false,
            stack: String(exceptionStacktrace),
        };
        const exceptionData = {
            exceptions: [exceptionDetails],
            severityLevel: String(getSeverity(log.severityNumber)),
            version: 2,
        };
        baseData = exceptionData;
    }
    else if (log.attributes[applicationinsights_js_1.ApplicationInsightsCustomEventName]) {
        name = applicationinsights_js_1.ApplicationInsightsEventName;
        baseType = applicationinsights_js_1.ApplicationInsightsEventBaseType;
        const eventData = {
            name: String(log.attributes[applicationinsights_js_1.ApplicationInsightsCustomEventName]),
            version: 2,
        };
        baseData = eventData;
        measurements = getLegacyApplicationInsightsMeasurements(log);
    }
    else if (isMessageType) {
        name = applicationinsights_js_1.ApplicationInsightsMessageName;
        baseType = applicationinsights_js_1.ApplicationInsightsMessageBaseType;
        const messageData = {
            message: (0, common_js_1.serializeAttribute)(log.body),
            severityLevel: String(getSeverity(log.severityNumber)),
            version: 2,
        };
        baseData = messageData;
    }
    else {
        // If Legacy Application Insights Log
        baseType = String(log.attributes[applicationinsights_js_1.ApplicationInsightsBaseType]);
        name = getLegacyApplicationInsightsName(log);
        baseData = getLegacyApplicationInsightsBaseData(log);
        measurements = getLegacyApplicationInsightsMeasurements(log);
        if (!baseData) {
            // Failed to parse log
            return;
        }
    }
    // Truncate properties
    if (baseData.message) {
        baseData.message = String(baseData.message).substring(0, types_js_2.MaxPropertyLengths.FIFTEEN_BIT);
    }
    if (properties) {
        for (const key of Object.keys(properties)) {
            properties[key] = String(properties[key]).substring(0, types_js_2.MaxPropertyLengths.THIRTEEN_BIT);
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: {
                ...baseData,
                properties,
                measurements,
            },
        },
    };
}
function createTagsFromLog(log) {
    const tags = (0, common_js_1.createTagsFromResource)(log.resource);
    if (log.spanContext?.traceId) {
        tags[index_js_1.KnownContextTagKeys.AiOperationId] = log.spanContext.traceId;
    }
    if (log.spanContext?.spanId) {
        tags[index_js_1.KnownContextTagKeys.AiOperationParentId] = log.spanContext.spanId;
    }
    if (log.attributes[index_js_1.KnownContextTagKeys.AiOperationName]) {
        tags[index_js_1.KnownContextTagKeys.AiOperationName] = log.attributes[index_js_1.KnownContextTagKeys.AiOperationName];
    }
    if ((0, common_js_1.isSyntheticSource)(log.attributes)) {
        tags[index_js_1.KnownContextTagKeys.AiOperationSyntheticSource] = "True";
    }
    // Set ai.location.ip from microsoft.client.ip if it exists
    const microsoftClientIp = log.attributes?.[applicationinsights_js_1.MicrosoftClientIp];
    if (microsoftClientIp) {
        tags[index_js_1.KnownContextTagKeys.AiLocationIp] = String(microsoftClientIp);
    }
    // Map user ID attributes
    const attributes = log.attributes;
    if (attributes[types_js_1.experimentalOpenTelemetryValues.ATTR_ENDUSER_ID]) {
        const endUserId = String(attributes[types_js_1.experimentalOpenTelemetryValues.ATTR_ENDUSER_ID]);
        if (endUserId && endUserId.length > 0) {
            tags[index_js_1.KnownContextTagKeys.AiUserAuthUserId] = endUserId;
        }
    }
    if (attributes[types_js_1.experimentalOpenTelemetryValues.ATTR_ENDUSER_PSEUDO_ID]) {
        const endUserPseudoId = String(attributes[types_js_1.experimentalOpenTelemetryValues.ATTR_ENDUSER_PSEUDO_ID]);
        if (endUserPseudoId && endUserPseudoId.length > 0) {
            tags[index_js_1.KnownContextTagKeys.AiUserId] = endUserPseudoId;
        }
    }
    return tags;
}
function createPropertiesFromLog(log) {
    const measurements = {};
    const properties = {};
    if (log.attributes) {
        for (const key of Object.keys(log.attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key.startsWith("microsoft") ||
                types_js_2.legacySemanticValues.includes(key) ||
                types_js_2.httpSemanticValues.includes(key) ||
                key === index_js_1.KnownContextTagKeys.AiOperationName)) {
                properties[key] = (0, common_js_1.serializeAttribute)(log.attributes[key]);
            }
        }
    }
    return [properties, measurements];
}
// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-severitynumber
function getSeverity(severityNumber) {
    if (severityNumber) {
        if (severityNumber > 0 && severityNumber < 9) {
            return index_js_1.KnownSeverityLevel.Verbose;
        }
        else if (severityNumber >= 9 && severityNumber < 13) {
            return index_js_1.KnownSeverityLevel.Information;
        }
        else if (severityNumber >= 13 && severityNumber < 17) {
            return index_js_1.KnownSeverityLevel.Warning;
        }
        else if (severityNumber >= 17 && severityNumber < 21) {
            return index_js_1.KnownSeverityLevel.Error;
        }
        else if (severityNumber >= 21 && severityNumber < 25) {
            return index_js_1.KnownSeverityLevel.Critical;
        }
    }
    return;
}
function getLegacyApplicationInsightsName(log) {
    let name = "";
    switch (log.attributes[applicationinsights_js_1.ApplicationInsightsBaseType]) {
        case applicationinsights_js_1.ApplicationInsightsAvailabilityBaseType:
            name = applicationinsights_js_1.ApplicationInsightsAvailabilityName;
            break;
        case applicationinsights_js_1.ApplicationInsightsExceptionBaseType:
            name = applicationinsights_js_1.ApplicationInsightsExceptionName;
            break;
        case applicationinsights_js_1.ApplicationInsightsMessageBaseType:
            name = applicationinsights_js_1.ApplicationInsightsMessageName;
            break;
        case applicationinsights_js_1.ApplicationInsightsPageViewBaseType:
            name = applicationinsights_js_1.ApplicationInsightsPageViewName;
            break;
        case applicationinsights_js_1.ApplicationInsightsEventBaseType:
            name = applicationinsights_js_1.ApplicationInsightsEventName;
            break;
    }
    return name;
}
function getLegacyApplicationInsightsMeasurements(log) {
    let measurements = {};
    if (log.body?.measurements) {
        measurements = { ...log.body.measurements };
    }
    return measurements;
}
function getLegacyApplicationInsightsBaseData(log) {
    let baseData = {
        version: 2,
    };
    if (log.body) {
        try {
            switch (log.attributes[applicationinsights_js_1.ApplicationInsightsBaseType]) {
                case applicationinsights_js_1.ApplicationInsightsAvailabilityBaseType:
                    baseData = log.body;
                    break;
                case applicationinsights_js_1.ApplicationInsightsExceptionBaseType:
                    baseData = log.body;
                    break;
                case applicationinsights_js_1.ApplicationInsightsMessageBaseType:
                    baseData = log.body;
                    break;
                case applicationinsights_js_1.ApplicationInsightsPageViewBaseType:
                    baseData = log.body;
                    break;
                case applicationinsights_js_1.ApplicationInsightsEventBaseType:
                    baseData = log.body;
                    break;
            }
            if (typeof baseData?.message === "object") {
                baseData.message = (0, common_js_1.serializeAttribute)(baseData.message);
            }
        }
        catch (err) {
            api_1.diag.error("AzureMonitorLogExporter failed to parse Application Insights Telemetry");
        }
    }
    return baseData;
}
//# sourceMappingURL=logUtils.js.map