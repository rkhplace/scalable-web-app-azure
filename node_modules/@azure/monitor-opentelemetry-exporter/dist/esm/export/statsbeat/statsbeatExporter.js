// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { context } from "@opentelemetry/api";
import { ExportResultCode, suppressTracing } from "@opentelemetry/core";
import { resourceMetricsToEnvelope } from "../../utils/metricUtils.js";
import { AzureMonitorBaseExporter } from "../base.js";
/**
 * Azure Monitor Statsbeat Exporter
 */
export class AzureMonitorStatsbeatExporter extends AzureMonitorBaseExporter {
    /**
     * Flag to determine if the Exporter is shutdown.
     */
    _isShutdown = false;
    _sender;
    _senderOptions;
    /**
     * Initializes a new instance of the AzureMonitorStatsbeatExporter class.
     * @param options - Exporter configuration
     */
    constructor(options) {
        super(options, true);
        // Store sender options for lazy initialization to avoid circular dependency
        this._senderOptions = {
            endpointUrl: this.endpointUrl,
            instrumentationKey: this.instrumentationKey,
            trackStatsbeat: this.trackStatsbeat,
            exporterOptions: options,
            isStatsbeatSender: true,
        };
    }
    /**
     * Lazily initialize the sender to avoid circular dependency
     */
    async _getSender() {
        if (!this._sender) {
            const { HttpSender } = await import("../../platform/nodejs/httpSender.js");
            this._sender = new HttpSender(this._senderOptions);
        }
        return this._sender;
    }
    /**
     * Filter out envelopes with zero metric values to prevent exporting zero counts.
     * This ensures zero counts are observed for internal cleanup but not exported to Azure Monitor.
     * @param envelopes - Array of telemetry envelopes to filter
     * @returns Filtered array of envelopes with non-zero metric values
     */
    filterZeroValueMetrics(envelopes) {
        return envelopes.filter((envelope) => {
            // Check if this is a metric envelope
            if (envelope.data?.baseType === "MetricData" && envelope.data?.baseData?.metrics) {
                const metrics = envelope.data.baseData.metrics;
                // Filter out metrics where all values are zero
                return metrics.some((metric) => metric.value !== 0);
            }
            return true;
        });
    }
    /**
     * Export Statsbeat metrics.
     */
    async export(metrics, resultCallback) {
        if (this._isShutdown) {
            setTimeout(() => resultCallback({ code: ExportResultCode.FAILED }), 0);
            return;
        }
        const envelopes = resourceMetricsToEnvelope(metrics, this.instrumentationKey, true);
        // Filter out zero-value metrics before export
        const filteredEnvelopes = this.filterZeroValueMetrics(envelopes);
        // Supress tracing until OpenTelemetry Metrics SDK support it
        context.with(suppressTracing(context.active()), async () => {
            const sender = await this._getSender();
            resultCallback(await sender.exportEnvelopes(filteredEnvelopes));
        });
    }
    /**
     * Shutdown AzureMonitorStatsbeatExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        if (this._sender) {
            return this._sender.shutdown();
        }
    }
    /**
     * Force flush.
     */
    async forceFlush() {
        return Promise.resolve();
    }
}
//# sourceMappingURL=statsbeatExporter.js.map